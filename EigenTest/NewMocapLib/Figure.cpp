//-----------------------------------------------------------------------------
//                             Figure.h
//
// キャラクタフィギュアクラス宣言部 
//
// $File: $
// $Author: numaguchi $
// $Date: 2011/10/30 $
// $Revision: 1$
//
//
//-----------------------------------------------------------------------------

//#include "stdafx.h"
#include "Figure.h"

//-----------------------------------------------------------------------------
// 説明: デフォルトコンストラクタ
// 引数: 
// 返り値:
// その他: 
//-----------------------------------------------------------------------------
CFigure::CFigure()
{
	m_pRoot = NULL;
}

//-----------------------------------------------------------------------------
// 説明: 初期化子付きコンストラクタ
// 引数: root [in] ルートノードへのポインタ
// 返り値:
// その他: 
//-----------------------------------------------------------------------------
CFigure::CFigure(CJoint *root)
{
	m_pRoot = NULL;
	Initialize(root);
}

//-----------------------------------------------------------------------------
// 説明: デストラクタ
// 引数: 
// 返り値:
// その他: 
//-----------------------------------------------------------------------------
CFigure::~CFigure(void)
{
	m_pRoot->Destroy();
}


//-----------------------------------------------------------------------------
// 説明: 初期化関数
// 引数: root [in] ルートノードへのポインタ
// 返り値:
// その他: 
//-----------------------------------------------------------------------------
void CFigure::Initialize(CJoint *root)
{
	if (m_pRoot != NULL)
		m_pRoot->Destroy();

	m_pRoot = root;
	ListingJoint(root);
}


//-----------------------------------------------------------------------------
// 説明: スケルトン木構造からのノードリストの作成
// 引数: root [in] ルートノードへのポインタ
// 返り値:
// その他: 
//-----------------------------------------------------------------------------
void CFigure::ListingJoint(CJoint *root)
{
	m_vecJoints.push_back(root);
	for (size_t i = 0; i < root->NumChildren(); ++i)
	{
		ListingJoint(root->GetChild(i));
	}
}

//-----------------------------------------------------------------------------
// 説明: 関節総数の取得
// 引数:
// 返り値:
//       関節総数
// その他: 
//-----------------------------------------------------------------------------
size_t CFigure::NumJoints() const
{
	return m_vecJoints.size();
}


//-----------------------------------------------------------------------------
// 説明: ルート位置の設定
// 引数: 
//       pos [in] 位置ベクトル
// 返り値:
// その他: 
//-----------------------------------------------------------------------------
void CFigure::SetRootPosition(const Vector3f &pos)
{
	m_pRoot->SetPosition(pos);
}

//-----------------------------------------------------------------------------
// 説明: ルート位置の取得
// 引数: 
// 返り値:
//       ルート位置ベクトル
// その他: 
//-----------------------------------------------------------------------------
Vector3f CFigure::GetRootPosition() const
{
	return m_pRoot->GetPosition();
}

//-----------------------------------------------------------------------------
// 説明: ルート方向の設定
// 引数: 
//       rot [in] ルート方向クォータニオン
// 返り値:
// その他: 
//-----------------------------------------------------------------------------
void CFigure::SetRootOrientation(const Quaternionf &rot)
{
	m_pRoot->SetRotation(rot);
}

//-----------------------------------------------------------------------------
// 説明: ルート方向の取得
// 引数: 
// 返り値:
//       ルート方向クォータニオン
// その他: 
//-----------------------------------------------------------------------------
Quaternionf CFigure::GetRootOrientation() const
{
	return m_pRoot->GetRotation();
}

//-----------------------------------------------------------------------------
// 説明: 関節回転量の設定
// 引数: 
//       jid [in] 関節インデクス
//       rot [in] 回転クォータニオン
// 返り値:
// その他: 
//-----------------------------------------------------------------------------
void CFigure::SetJointRotation(size_t jid, const Quaternionf &rot)
{
	m_vecJoints[jid]->SetRotation(rot);
}

//-----------------------------------------------------------------------------
// 説明: 関節回転量の取得
// 引数: 
//       jid [in] 関節インデクス
// 返り値:
//       回転クォータニオン
// その他: 
//-----------------------------------------------------------------------------
Quaternionf CFigure::GetJointRotation(size_t jid) const
{
	return m_vecJoints[jid]->GetRotation();
}


//-----------------------------------------------------------------------------
// 説明: ルートノードへのポインタの取得
// 引数: 
// 返り値:
//       ルートノードへのポインタ
// その他: 
//-----------------------------------------------------------------------------
CJoint* CFigure::GetRoot()
{
	return m_pRoot;
}

//-----------------------------------------------------------------------------
// 説明: ルートノードへのポインタの取得(const)
// 引数: 
// 返り値:
//       ルートノードへのポインタ(const)
// その他: 
//-----------------------------------------------------------------------------
const CJoint* CFigure::GetRoot() const
{
	return m_pRoot;
}

//-----------------------------------------------------------------------------
// 説明: 関数ノードへのポインタの取得
// 引数: 
// 返り値:
//       関節ノードへのポインタ
// その他: 
//-----------------------------------------------------------------------------
CJoint* CFigure::GetJoint(size_t jid)
{
	return m_vecJoints[jid];
}

//-----------------------------------------------------------------------------
// 説明: 関節ノードへのポインタの取得(const)
// 引数: 
// 返り値:
//       関節ノードへのポインタ(const)
// その他: 
//-----------------------------------------------------------------------------
const CJoint* CFigure::GetJoint(size_t jid) const
{
	return m_vecJoints[jid];
}

//-----------------------------------------------------------------------------
// 説明: 関節ノードのワールド座標の取得
// 引数: 
//       jid [in] 関節インデクス
// 返り値:
//       関節ノードのワールド座標ベクトル
// その他: 
//-----------------------------------------------------------------------------
Vector3f CFigure::GetWorldPosition(size_t jid) const
{
	//Vector3f vTmp(0, 0, 0), vWorldPos(0, 0, 0);
	//Matrix4f mTrans = Matrix4f::Identity();

	Vector4f vTmp(0, 0, 0, 1), vWorldPos(0, 0, 0, 1);
	Matrix4f mTrans = Matrix4f::Identity();

	mTrans = m_vecJoints[jid]->GetOffsetMatrix();
	vWorldPos = vTmp.transpose() * mTrans;
	//D3DXVec3TransformCoord(&vWorldPos, &vTmp, &mTrans);

	for (CJoint *pNode = m_vecJoints[jid]->GetParent();pNode != NULL;pNode = pNode->GetParent())
	{
		mTrans = pNode->GetTransformMatrix();
		vTmp = vWorldPos;
		vWorldPos = vTmp.transpose() * mTrans;
		//D3DXVec3TransformCoord(&vWorldPos, &vTmp, &mTrans);
	}
	return Vector3f(vWorldPos.x(), vWorldPos.y(), vWorldPos.z());
}

//-----------------------------------------------------------------------------
// 説明: 指定関節ノードがエフェクタかチェック
// 引数: 
//       jid [in] 関節ノードインデクス
// 返り値:
//       true エフェクタ
//       false エフェクタではない
// その他: 
//-----------------------------------------------------------------------------
bool CFigure::IsEffector(size_t jid) const
{
	if (m_vecJoints[jid]->NumChildren() > 0)
		return false;
	return true;
}

//-----------------------------------------------------------------------------
// 説明: モーションデータの姿勢に設定
// 引数: 
//       mot [in] モーションデータ
//       frm [in] フレーム番号
// 返り値:
//       true 設定成功
//       false 設定失敗
// その他: 
//-----------------------------------------------------------------------------
bool CFigure::SetPose(const CMotionData *mot, size_t frm)
{
	if (NumJoints() != mot->NumJoints() || frm >= mot->NumFrames())
		return false;

	SetRootPosition( mot->GetPosition(frm) );
	for (size_t i = 0, j = 0;j < mot->NumJoints();++i)
	{
		SetJointRotation(i, mot->GetRotation(frm, j++));
	}
	return true;
}

//-----------------------------------------------------------------------------
// 説明: 関節ノードへのポインタからノードインデクスの検索
// 引数: 
//       node [in] 関節ノードへのポインタ
// 返り値:
//       関節ノードインデクス
// その他: 
//-----------------------------------------------------------------------------
int CFigure::FindNode(CJoint *node) const
{
	int id = -1;
	for (int i = 0;static_cast<size_t>(i) < m_vecJoints.size();++i)
	{
		if (node == m_vecJoints[i])
		{
			id = i;
			break;
		}
	}
	return id;
}

//-----------------------------------------------------------------------------
// 説明: 関節名からノードインデクスの検索
// 引数: 
//       name [in] 関節名
// 返り値:
//       関節ノードインデクス
// その他: 
//-----------------------------------------------------------------------------
int CFigure::FindNode(const char *name) const
{
	int id = -1;
	for (int i = 0;static_cast<size_t>(i) < m_vecJoints.size();++i)
	{
		if (strcmp(name, m_vecJoints[i]->GetName()) == 0)
		{
			id = i;
			break;
		}
	}
	return id;
}